#ifndef OSMIUM_IO_DETAIL_PBF_OUTPUT_FORMAT_HPP
#define OSMIUM_IO_DETAIL_PBF_OUTPUT_FORMAT_HPP

/*

This file is part of Osmium (http://osmcode.org/libosmium).

Copyright 2013-2015 Jochen Topf <jochen@topf.org> and others (see README).

Boost Software License - Version 1.0 - August 17th, 2003

Permission is hereby granted, free of charge, to any person or organization
obtaining a copy of the software and accompanying documentation covered by
this license (the "Software") to use, reproduce, display, distribute,
execute, and transmit the Software, and to prepare derivative works of the
Software, and to permit third-parties to whom the Software is furnished to
do so, all subject to the following:

The copyright notices in the Software and this entire statement, including
the above license grant, this restriction and the following disclaimer,
must be included in all copies of the Software, in whole or in part, and
all derivative works of the Software, unless such copies or derivative
works are solely in the form of machine-executable object code generated by
a source language processor.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
DEALINGS IN THE SOFTWARE.

*/

#include <algorithm>
#include <chrono>
#include <cmath>
#include <cstdint>
#include <cstdlib>
#include <future>
#include <iostream>
#include <iterator>
#include <memory>
#include <ratio>
#include <string>
#include <thread>
#include <time.h>
#include <utility>

#include <boost/iterator/transform_iterator.hpp>

#include <protozero/pbf_writer.hpp>

#include <osmium/handler.hpp>
#include <osmium/io/detail/output_format.hpp>
#include <osmium/io/detail/pbf.hpp> // IWYU pragma: export
#include <osmium/io/detail/zlib.hpp>
#include <osmium/io/file.hpp>
#include <osmium/io/file_format.hpp>
#include <osmium/io/header.hpp>
#include <osmium/memory/buffer.hpp>
#include <osmium/memory/collection.hpp>
#include <osmium/osm/box.hpp>
#include <osmium/osm/item_type.hpp>
#include <osmium/osm/location.hpp>
#include <osmium/osm/node.hpp>
#include <osmium/osm/object.hpp>
#include <osmium/osm/relation.hpp>
#include <osmium/osm/tag.hpp>
#include <osmium/osm/timestamp.hpp>
#include <osmium/osm/way.hpp>
#include <osmium/util/cast.hpp>
#include <osmium/util/delta.hpp>
#include <osmium/visitor.hpp>

namespace osmium {

    namespace io {

        namespace detail {

            /**
             * Maximum number of items in a primitive block.
             *
             * The uncompressed length of a Blob *should* be less
             * than 16 megabytes and *must* be less than 32 megabytes.
             *
             * A block may contain any number of entities, as long as
             * the size limits for the surrounding blob are obeyed.
             * However, for simplicity, the current Osmosis (0.38)
             * as well as Osmium implementation always
             * uses at most 8k entities in a block.
             */
            constexpr int32_t max_entities_per_block = 8000;

            constexpr int location_granularity = 100;

            /**
             * convert a double lat or lon value to an int, respecting the granularity
             */
            inline int64_t lonlat2int(double lonlat) {
                return static_cast<int64_t>(std::round(lonlat * lonlat_resolution / location_granularity));
            }

            /**
             * Serialize a protobuf message into a Blob, optionally apply compression
             * and return it together with a BlobHeader ready to be written to a file.
             *
             * @param type Type-string used in the BlobHeader.
             * @param msg Protobuf-message.
             * @param use_compression Should the output be compressed using zlib?
             */
            inline std::string serialize_blob(const std::string& type, const std::string& msg, bool use_compression) {
                std::string blob_data;
                protozero::pbf_writer pbf_blob(blob_data);

                if (!use_compression) {
                    pbf_blob.add_bytes(1 /* optional bytes raw */, msg);
                }

                pbf_blob.add_int32(2 /* optional int32 raw_size */, msg.size());

                if (use_compression) {
                    pbf_blob.add_bytes(3 /* optional bytes zlib_data */, osmium::io::detail::zlib_compress(msg));
                }

                std::string blob_header_data;
                protozero::pbf_writer pbf_blob_header(blob_header_data);

                pbf_blob_header.add_string(1 /* required string type */, type);
                pbf_blob_header.add_int32(3 /* required int32 datasize */, blob_data.size());

                uint32_t sz = htonl(static_cast_with_assert<uint32_t>(blob_header_data.size()));

                // write to output: the 4-byte BlobHeader-Size followed by the BlobHeader followed by the Blob
                std::string output;
                output.reserve(sizeof(sz) + blob_header_data.size() + blob_data.size());
                output.append(reinterpret_cast<const char*>(&sz), sizeof(sz));
                output.append(blob_header_data);
                output.append(blob_data);

                return output;
            }

            struct StrComp {

                bool operator()(const char* lhs, const char* rhs) const {
                    return strcmp(lhs, rhs) < 0;
                }

            }; // struct StrComp

            class Stringtable {

                std::map<const char*, size_t, StrComp> m_index;
                std::vector<std::string> m_strings;
                size_t m_size;

            public:

                Stringtable() :
                    m_index(),
                    m_strings(),
                    m_size(2) {
                    m_strings.push_back("");
                }

                void clear() {
                    m_strings.clear();
                    m_strings.push_back("");
                    m_index.clear();
                    m_size = 2;
                }

                size_t size() const {
                    return m_size;
                }

                size_t add(const char* s) {
                    auto f = m_index.find(s);
                    if (f != m_index.end()) {
                        return f->second;
                    }

                    size_t n = m_strings.size();
                    m_strings.emplace_back(s);
                    m_index[m_strings[n].c_str()] = n;
                    m_size += strlen(s) + 2;
                    return n;
                }

                void write(protozero::pbf_writer& pbf_string_table) {
                    for (const auto& s : m_strings) {
                        pbf_string_table.add_bytes(1 /* repeated bytes s */, s);
                    }
                }

            }; // class Stringtable

            class DenseNodes {

                Stringtable& m_stringtable;

                std::vector<int64_t> m_ids;

                std::vector<int32_t> m_versions;
                std::vector<int64_t> m_timestamps;
                std::vector<int64_t> m_changesets;
                std::vector<int32_t> m_uids;
                std::vector<int32_t> m_user_sids;
                std::vector<bool> m_visibles;

                std::vector<int64_t> m_lats;
                std::vector<int64_t> m_lons;
                std::vector<int32_t> m_tags;

                osmium::util::DeltaEncode<int64_t> m_delta_id;

                osmium::util::DeltaEncode<int64_t> m_delta_timestamp;
                osmium::util::DeltaEncode<int64_t> m_delta_changeset;
                osmium::util::DeltaEncode<int32_t> m_delta_uid;
                osmium::util::DeltaEncode<int32_t> m_delta_user_sid;

                osmium::util::DeltaEncode<int64_t> m_delta_lat;
                osmium::util::DeltaEncode<int64_t> m_delta_lon;

                bool m_should_add_metadata;
                bool m_add_visible;

            public:

                DenseNodes(Stringtable& stringtable, bool should_add_metadata, bool add_visible) :
                    m_stringtable(stringtable),
                    m_should_add_metadata(should_add_metadata),
                    m_add_visible(add_visible) {
                }

                void clear() {
                    m_ids.clear();

                    m_versions.clear();
                    m_timestamps.clear();
                    m_changesets.clear();
                    m_uids.clear();
                    m_user_sids.clear();
                    m_visibles.clear();

                    m_lats.clear();
                    m_lons.clear();
                    m_tags.clear();

                    m_delta_id.clear();

                    m_delta_timestamp.clear();
                    m_delta_changeset.clear();
                    m_delta_uid.clear();
                    m_delta_user_sid.clear();

                    m_delta_lat.clear();
                    m_delta_lon.clear();
                }

                size_t size() const {
                    return m_ids.size() * 3 * sizeof(int64_t);
                }

                void add_node(const osmium::Node& node) {
                    m_ids.push_back(m_delta_id.update(node.id()));

                    if (m_should_add_metadata) {
                        m_versions.push_back(node.version());
                        m_timestamps.push_back(m_delta_timestamp.update(node.timestamp()));
                        m_changesets.push_back(m_delta_changeset.update(node.changeset()));
                        m_uids.push_back(m_delta_uid.update(node.uid()));
                        m_user_sids.push_back(m_delta_user_sid.update(m_stringtable.add(node.user())));
                        if (m_add_visible) {
                            m_visibles.push_back(node.visible());
                        }
                    }

                    m_lats.push_back(m_delta_lat.update(lonlat2int(node.location().lat_without_check())));
                    m_lons.push_back(m_delta_lon.update(lonlat2int(node.location().lon_without_check())));

                    for (const auto& tag : node.tags()) {
                        m_tags.push_back(m_stringtable.add(tag.key()));
                        m_tags.push_back(m_stringtable.add(tag.value()));
                    }
                    m_tags.push_back(0);
                }

                std::string serialize() const {
                    std::string data;
                    protozero::pbf_writer pbf_dense_nodes(data);

                    pbf_dense_nodes.add_packed_sint64(1 /* repeated sint64 id [packed = true] */, m_ids.cbegin(), m_ids.cend());

                    if (m_should_add_metadata) {
                        protozero::pbf_writer pbf_dense_info(pbf_dense_nodes, 5 /* optional DenseInfo densinfo */);
                        pbf_dense_info.add_packed_int32(1 /* repeated int32 version [packed = true] */, m_versions.cbegin(), m_versions.cend());
                        pbf_dense_info.add_packed_sint64(2 /* repeated sint64 timestamp [packed = true] */, m_timestamps.cbegin(), m_timestamps.cend());
                        pbf_dense_info.add_packed_sint64(3 /* repeated sint64 changeset [packed = true] */, m_changesets.cbegin(), m_changesets.cend());
                        pbf_dense_info.add_packed_sint32(4 /* repeated sint32 uid [packed = true] */, m_uids.cbegin(), m_uids.cend());
                        pbf_dense_info.add_packed_sint32(5 /* repeated sint32 user_sid [packed = true] */, m_user_sids.cbegin(), m_user_sids.cend());

                        if (m_add_visible) {
                            pbf_dense_info.add_packed_bool(6 /* repeated bool visible [packed = true] */, m_visibles.cbegin(), m_visibles.cend());
                        }
                    }

                    pbf_dense_nodes.add_packed_sint64(8 /* repeated sint64 lat [packed = true] */, m_lats.cbegin(), m_lats.cend());
                    pbf_dense_nodes.add_packed_sint64(9 /* repeated sint64 lon [packed = true] */, m_lons.cbegin(), m_lons.cend());

                    pbf_dense_nodes.add_packed_int32(10 /* repeated int32 keys_vals [packed = true] */, m_tags.cbegin(), m_tags.cend());

                    return data;
                }

            }; // class DenseNodes

            class PBFPrimitiveBlock {

                std::string m_pbf_primitive_group_data;
                Stringtable m_stringtable;
                DenseNodes m_dense_nodes;
                protozero::pbf_writer m_pbf_primitive_group;
                int m_type;
                int m_count;

            public:

                PBFPrimitiveBlock(bool should_add_metadata, bool add_visible) :
                    m_pbf_primitive_group_data(),
                    m_stringtable(),
                    m_dense_nodes(m_stringtable, should_add_metadata, add_visible),
                    m_pbf_primitive_group(m_pbf_primitive_group_data),
                    m_type(0),
                    m_count(0) {
                }

                const std::string& group_data() {
                    if (type() == 2) { // dense nodes
                        m_pbf_primitive_group.add_message(2 /* optional DenseNodes dense */, m_dense_nodes.serialize());
                    }
                    return m_pbf_primitive_group_data;
                }

                void reset(int type) {
                    m_pbf_primitive_group_data.clear();
                    m_stringtable.clear();
                    m_dense_nodes.clear();
                    m_type = type;
                    m_count = 0;
                }

                void write_stringtable(protozero::pbf_writer& pbf) {
                    m_stringtable.write(pbf);
                }

                protozero::pbf_writer& group() {
                    ++m_count;
                    return m_pbf_primitive_group;
                }

                void add_dense_node(const osmium::Node& node) {
                    m_dense_nodes.add_node(node);
                    ++m_count;
                }

                size_t add_string(const char* s) {
                    return m_stringtable.add(s);
                }

                int count() const {
                    return m_count;
                }

                int type() const {
                    return m_type;
                }

                size_t size() const {
                    return m_pbf_primitive_group_data.size() + m_stringtable.size() + m_dense_nodes.size();
                }

                // fill blocks to 90% of max size.
                constexpr static size_t max_used_blob_size = max_uncompressed_blob_size * 9 / 10;

                bool can_add(int type) const {
                    if (type != m_type) {
                        return false;
                    }
                    if (count() >= max_entities_per_block) {
                        return false;
                    }
                    return size() < max_used_blob_size;
                }

            }; // class PBFPrimitiveBlock

            class PBFOutputFormat : public osmium::io::detail::OutputFormat, public osmium::handler::Handler {

                /**
                 * The output buffer (block) will be filled to about
                 * 95% and then written to disk. This leaves more than
                 * enough space for the string table (which typically
                 * needs about 0.1 to 0.3% of the block size).
                 */
                static constexpr int64_t buffer_fill_percent = 95;

                /**
                 * should nodes be serialized into the dense format?
                 *
                 * nodes can be encoded one of two ways, as a Node
                 * (m_use_dense_nodes = false) and a special dense format.
                 * In the dense format, all information is stored 'column wise',
                 * as an array of ID's, array of latitudes, and array of
                 * longitudes. Each column is delta-encoded. This reduces
                 * header overheads and allows delta-coding to work very effectively.
                 */
                bool m_use_dense_nodes;

                /**
                 * should the PBF blobs contain zlib compressed data?
                 *
                 * the zlib compression is optional, it's possible to store the
                 * blobs in raw format. Disabling the compression can improve the
                 * writing speed a little but the output will be 2x to 3x bigger.
                 */
                bool m_use_compression;

                /**
                 * Should the string tables in the data blocks be sorted?
                 *
                 * Not sorting the string tables makes writing PBF files
                 * slightly faster.
                 */
                bool m_sort_stringtables;

                /**
                 * While the .osm.pbf-format is able to carry all meta information, it is
                 * also able to omit this information to reduce size.
                 */
                bool m_should_add_metadata;

                /**
                 * Should the visible flag be added on objects?
                 */
                bool m_add_visible;

                /**
                 * protobuf-struct of a PrimitiveBlock
                 */
                PBFPrimitiveBlock m_pbf_primitive_block;

                bool debug;

                bool has_debug_level(int) {
                    return false;
                }

                void store_primitive_block() {
                    if (m_pbf_primitive_block.type() == 0 || m_pbf_primitive_block.count() == 0) {
                        return;
                    }

                    if (debug && has_debug_level(1)) {
                        std::cerr << "storing primitive block with " << m_pbf_primitive_block.count() << " items\n";
                    }

                    std::string primitive_block_data;
                    protozero::pbf_writer pbf_primitive_block(primitive_block_data);

                    {
                        protozero::pbf_writer pbf_string_table(pbf_primitive_block, 1 /* required StringTable stringtable */);
                        m_pbf_primitive_block.write_stringtable(pbf_string_table);
                    }

                    pbf_primitive_block.add_message(2 /* repeated PrimitiveGroup primitivegroup */, m_pbf_primitive_block.group_data());

                    std::promise<std::string> promise;
                    m_output_queue.push(promise.get_future());
                    promise.set_value(serialize_blob("OSMData", primitive_block_data, m_use_compression));
                }

                void add_meta(const osmium::OSMObject& object, protozero::pbf_writer& pbf_object) {
                    const osmium::TagList& tags = object.tags();

                    auto map_tag_key = [this](const osmium::Tag& tag) {
                        return m_pbf_primitive_block.add_string(tag.key());
                    };
                    auto map_tag_value = [this](const osmium::Tag& tag) {
                        return m_pbf_primitive_block.add_string(tag.value());
                    };

                    pbf_object.add_packed_uint32(2 /* keys */,
                        boost::make_transform_iterator(tags.begin(), map_tag_key),
                        boost::make_transform_iterator(tags.end(), map_tag_key));

                    pbf_object.add_packed_uint32(3 /* vals */,
                        boost::make_transform_iterator(tags.begin(), map_tag_value),
                        boost::make_transform_iterator(tags.end(), map_tag_value));

                    if (m_should_add_metadata) {
                        protozero::pbf_writer pbf_info(pbf_object, 4 /* info */);

                        pbf_info.add_int32(1 /* version */, object.version());
                        pbf_info.add_int64(2 /* timestamp */, object.timestamp());
                        pbf_info.add_int64(3 /* changeset */, object.changeset());
                        pbf_info.add_int32(4 /* uid */, object.uid());
                        pbf_info.add_uint32(5 /* user_sid */, m_pbf_primitive_block.add_string(object.user()));
                        if (m_add_visible) {
                            pbf_info.add_bool(6 /* visible*/, object.visible());
                        }
                    }
                }

                PBFOutputFormat(const PBFOutputFormat&) = delete;
                PBFOutputFormat& operator=(const PBFOutputFormat&) = delete;

            public:

                explicit PBFOutputFormat(const osmium::io::File& file, data_queue_type& output_queue) :
                    OutputFormat(file, output_queue),
                    m_use_dense_nodes(file.get("pbf_dense_nodes") != "false"),
                    m_use_compression(file.get("pbf_compression") != "none" && file.get("pbf_compression") != "false"),
                    m_sort_stringtables(file.get("pbf_sort_stringtables") != "false"),
                    m_should_add_metadata(file.get("pbf_add_metadata") != "false"),
                    m_add_visible(file.has_multiple_object_versions()),
                    m_pbf_primitive_block(m_should_add_metadata, m_add_visible),
                    debug(true) {
                }

                void write_buffer(osmium::memory::Buffer&& buffer) override final {
                    osmium::apply(buffer.cbegin(), buffer.cend(), *this);
                }

                void write_header(const osmium::io::Header& header) override final {
                    std::string data;
                    protozero::pbf_writer pbf_header_block(data);

                    if (!header.boxes().empty()) {
                        protozero::pbf_writer pbf_header_bbox(pbf_header_block, 1 /* bbox */);

                        osmium::Box box = header.joined_boxes();
                        pbf_header_bbox.add_sint64(1 /* left */, box.bottom_left().lon() * lonlat_resolution);
                        pbf_header_bbox.add_sint64(2 /* right */, box.top_right().lon() * lonlat_resolution);
                        pbf_header_bbox.add_sint64(3 /* top */, box.top_right().lat() * lonlat_resolution);
                        pbf_header_bbox.add_sint64(4 /* bottom */, box.bottom_left().lat() * lonlat_resolution);
                    }

                    // add the schema version as required feature to the HeaderBlock
                    pbf_header_block.add_string(4 /* required_features */, "OsmSchema-V0.6");

                    // when the densenodes-feature is used, add DenseNodes as required feature
                    if (m_use_dense_nodes) {
                        pbf_header_block.add_string(4 /* required_features */, "DenseNodes");
                    }

                    // when the resulting file will carry history information, add
                    // HistoricalInformation as required feature
                    if (m_file.has_multiple_object_versions()) {
                        pbf_header_block.add_string(4 /* required_features */, "HistoricalInformation");
                    }

                    // set the writing program
                    pbf_header_block.add_string(16 /* writingprogram */, header.get("generator"));

                    std::string osmosis_replication_timestamp = header.get("osmosis_replication_timestamp");
                    if (!osmosis_replication_timestamp.empty()) {
                        osmium::Timestamp ts(osmosis_replication_timestamp.c_str());
                        pbf_header_block.add_int64(32 /* osmosis_replication_timestamp */, ts);
                    }

                    std::string osmosis_replication_sequence_number = header.get("osmosis_replication_sequence_number");
                    if (!osmosis_replication_sequence_number.empty()) {
                        pbf_header_block.add_int64(33 /* osmosis_replication_sequence_number */, std::atoll(osmosis_replication_sequence_number.c_str()));
                    }

                    std::string osmosis_replication_base_url = header.get("osmosis_replication_base_url");
                    if (!osmosis_replication_base_url.empty()) {
                        pbf_header_block.add_string(34 /* osmosis_replication_base_url */, osmosis_replication_base_url);
                    }

                    if (debug && has_debug_level(1)) {
                        std::cerr << "storing header block" << std::endl;
                    }

                    std::promise<std::string> promise;
                    m_output_queue.push(promise.get_future());
                    promise.set_value(serialize_blob("OSMHeader", data, m_use_compression));
                }

                void primitive_block_type(int type) {
                    if (!m_pbf_primitive_block.can_add(type)) {
                        store_primitive_block();
                        m_pbf_primitive_block.reset(type);
                    }
                }

                protozero::pbf_writer pbf_group(int type) {
                    primitive_block_type(type);
                    return protozero::pbf_writer(m_pbf_primitive_block.group(), type);
                }

                void node(const osmium::Node& node) {
                    if (m_use_dense_nodes) {
                        primitive_block_type(2 /* DenseNode*/);
                        m_pbf_primitive_block.add_dense_node(node);
                        return;
                    }

                    protozero::pbf_writer pbf_node = pbf_group(1 /* Node */);

                    pbf_node.add_sint64(1 /* id */, node.id());
                    add_meta(node, pbf_node);

                    pbf_node.add_sint64(8 /* lat */, lonlat2int(node.location().lat_without_check()));
                    pbf_node.add_sint64(9 /* lon */, lonlat2int(node.location().lon_without_check()));
                }

                void way(const osmium::Way& way) {
                    static auto map_node_ref = [](osmium::NodeRefList::const_iterator node_ref) noexcept {
                        return node_ref->ref();
                    };
                    typedef osmium::util::DeltaEncodeIterator<osmium::NodeRefList::const_iterator, decltype(map_node_ref), osmium::object_id_type> it_type;

                    protozero::pbf_writer pbf_way = pbf_group(3 /* Way */);

                    pbf_way.add_int64(1 /* id */, way.id());
                    add_meta(way, pbf_way);

                    const auto& nodes = way.nodes();
                    it_type first { nodes.cbegin(), nodes.cend(), map_node_ref };
                    it_type last { nodes.cend(), nodes.cend(), map_node_ref };
                    pbf_way.add_packed_sint64(8 /* refs */, first, last);
                }

                void relation(const osmium::Relation& relation) {
                    protozero::pbf_writer pbf_relation = pbf_group(4 /* Relation */);

                    pbf_relation.add_int64(1 /* id */, relation.id());
                    add_meta(relation, pbf_relation);

                    auto map_member_role = [this](const osmium::RelationMember& member) {
                        return m_pbf_primitive_block.add_string(member.role());
                    };
                    pbf_relation.add_packed_int32(8 /* roles_sid */,
                        boost::make_transform_iterator(relation.members().begin(), map_member_role),
                        boost::make_transform_iterator(relation.members().end(), map_member_role));

                    static auto map_member_ref = [](osmium::RelationMemberList::const_iterator member) noexcept {
                        return member->ref();
                    };
                    typedef osmium::util::DeltaEncodeIterator<osmium::RelationMemberList::const_iterator, decltype(map_member_ref), osmium::object_id_type> it_type;
                    const auto& members = relation.members();
                    it_type first { members.cbegin(), members.cend(), map_member_ref };
                    it_type last { members.cend(), members.cend(), map_member_ref };
                    pbf_relation.add_packed_sint64(9 /* memids */, first, last);

                    static auto map_member_type = [](const osmium::RelationMember& member) noexcept {
                        return osmium::item_type_to_nwr_index(member.type());
                    };
                    pbf_relation.add_packed_int32(10 /* types */,
                        boost::make_transform_iterator(relation.members().begin(), map_member_type),
                        boost::make_transform_iterator(relation.members().end(), map_member_type));
                }

                /**
                 * Finalize the writing process, flush any open primitive
                 * blocks to the file and close the file.
                 */
                void close() override final {
                    if (debug && has_debug_level(1)) {
                        std::cerr << "finishing" << std::endl;
                    }

                    store_primitive_block();

                    std::promise<std::string> promise;
                    m_output_queue.push(promise.get_future());
                    promise.set_value(std::string());
                }

            }; // class PBFOutputFormat

            namespace {

// we want the register_output_format() function to run, setting the variable
// is only a side-effect, it will never be used
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wunused-variable"
                const bool registered_pbf_output = osmium::io::detail::OutputFormatFactory::instance().register_output_format(osmium::io::file_format::pbf,
                    [](const osmium::io::File& file, data_queue_type& output_queue) {
                        return new osmium::io::detail::PBFOutputFormat(file, output_queue);
                });
#pragma GCC diagnostic pop

            } // anonymous namespace

        } // namespace detail

    } // namespace io

} // namespace osmium

#endif // OSMIUM_IO_DETAIL_PBF_OUTPUT_FORMAT_HPP
