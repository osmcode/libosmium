#ifndef OSMIUM_BUILDER_ATTR_HPP
#define OSMIUM_BUILDER_ATTR_HPP

/*

This file is part of Osmium (http://osmcode.org/libosmium).

Copyright 2013-2016 Jochen Topf <jochen@topf.org> and others (see README).

Boost Software License - Version 1.0 - August 17th, 2003

Permission is hereby granted, free of charge, to any person or organization
obtaining a copy of the software and accompanying documentation covered by
this license (the "Software") to use, reproduce, display, distribute,
execute, and transmit the Software, and to prepare derivative works of the
Software, and to permit third-parties to whom the Software is furnished to
do so, all subject to the following:

The copyright notices in the Software and this entire statement, including
the above license grant, this restriction and the following disclaimer,
must be included in all copies of the Software, in whole or in part, and
all derivative works of the Software, unless such copies or derivative
works are solely in the form of machine-executable object code generated by
a source language processor.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
DEALINGS IN THE SOFTWARE.

*/

#include <cstdint>
#include <initializer_list>
#include <iterator>
#include <string>
#include <tuple>
#include <type_traits>
#include <utility>

#include <osmium/builder/osm_object_builder.hpp>
#include <osmium/memory/buffer.hpp>
#include <osmium/osm/types.hpp>

namespace osmium {

    namespace builder {

        namespace detail {

            // True if Predicate matches for none of the types Ts
            template <template<typename> class Predicate, typename... Ts>
            struct static_none_of : std::is_same<std::tuple<std::false_type, typename Predicate<Ts>::type...>,
                                                 std::tuple<typename Predicate<Ts>::type..., std::false_type>>
            {};

            // True if Predicate matches for all of the types Ts
            template <template<typename> class Predicate, typename... Ts>
            struct static_all_of : std::is_same<std::tuple<std::true_type, typename Predicate<Ts>::type...>,
                                                std::tuple<typename Predicate<Ts>::type..., std::true_type>>
            {};

            // True if THandler is derived from the handler for at least one of the types in TTypes
            template <typename THandler, typename... TTypes>
            struct is_handled_by {
                template <typename T>
                using HasHandler = std::is_base_of<typename T::handler, THandler>;
                static constexpr bool any = !static_none_of<HasHandler, TTypes...>::value;
                static constexpr bool all = static_all_of<HasHandler, TTypes...>::value;
            };

            // True if THandler is derived from the handlers of all the types in TTypes
            template <typename THandler, typename... TTypes>
            struct are_all_handled_by {
                template <typename T>
                using HasHandler = std::is_base_of<typename T::handler, THandler>;
                static constexpr bool value = static_all_of<HasHandler, TTypes...>::value;
            };


            template <typename TType>
            struct type_wrapper {

                using type = TType;

                TType value;

                constexpr explicit type_wrapper(const TType& v) :
                    value(v) {
                }

            }; // struct type_wrapper

            template <typename TType>
            struct iterator_wrapper {

                using type = TType;

                TType first;
                TType last;

                constexpr iterator_wrapper(TType begin, TType end) :
                    first(begin),
                    last(end) {}

                constexpr TType begin() const {
                    return first;
                }

                constexpr TType end() const {
                    return last;
                }

            }; // struct iterator_wrapper


            struct basic_handler;
            struct node_handler;
            struct tags_handler;
            struct nodes_handler;
            struct members_handler;

        } // namespace detail

#define OSMIUM_ATTRIBUTE(_handler, _name, _type) \
    struct _name : public osmium::builder::detail::type_wrapper<_type> { \
        using handler = osmium::builder::detail::_handler;

#define OSMIUM_ATTRIBUTE_WITH_CONSTRUCTOR(_handler, _name, _type) \
    OSMIUM_ATTRIBUTE(_handler, _name, _type) \
        constexpr explicit _name(std::add_const<_type>::type& value) : \
            type_wrapper(value) {} \
    }

#define OSMIUM_ATTRIBUTE_ITER(_handler, _name) \
    template <typename TIterator> \
    struct _name : public osmium::builder::detail::iterator_wrapper<TIterator> { \
        using handler = osmium::builder::detail::_handler; \
        constexpr _name(TIterator first, TIterator last) : \
            osmium::builder::detail::iterator_wrapper<TIterator>(first, last) {} \
    }

        namespace attr {

            OSMIUM_ATTRIBUTE_WITH_CONSTRUCTOR(basic_handler, _id, osmium::object_id_type);
            OSMIUM_ATTRIBUTE_WITH_CONSTRUCTOR(basic_handler, _version, osmium::object_version_type);
            OSMIUM_ATTRIBUTE_WITH_CONSTRUCTOR(basic_handler, _uid, osmium::user_id_type);
            OSMIUM_ATTRIBUTE_WITH_CONSTRUCTOR(basic_handler, _changeset, osmium::changeset_id_type);

            OSMIUM_ATTRIBUTE(basic_handler, _deleted, bool)
                constexpr explicit _deleted(bool value = true) :
                    type_wrapper(value) {}
            };

            OSMIUM_ATTRIBUTE(basic_handler, _visible, bool)
                constexpr explicit _visible(bool value = true) :
                    type_wrapper(value) {}
            };

            OSMIUM_ATTRIBUTE(basic_handler, _timestamp, osmium::Timestamp)
                constexpr explicit _timestamp(const osmium::Timestamp& value) :
                    type_wrapper(value) {}
                constexpr explicit _timestamp(time_t value) :
                    type_wrapper(osmium::Timestamp{value}) {}
                constexpr explicit _timestamp(uint32_t value) :
                    type_wrapper(osmium::Timestamp{value}) {}
                explicit _timestamp(const char* value) :
                    type_wrapper(osmium::Timestamp{value}) {}
                explicit _timestamp(const std::string& value) :
                    type_wrapper(osmium::Timestamp{value}) {}
            };

            OSMIUM_ATTRIBUTE(node_handler, _location, osmium::Location)
                constexpr explicit _location(const osmium::Location& value) :
                    type_wrapper(value) {}
                explicit _location(double lat, double lon) :
                    type_wrapper(osmium::Location{lat, lon}) {}
            };

            OSMIUM_ATTRIBUTE(basic_handler, _user, const char*)
                explicit _user(const char* val) :
                    type_wrapper(val) {}
                explicit _user(const std::string& val) :
                    type_wrapper(val.c_str()) {}
            };

            using pair_of_cstrings = std::pair<const char*, const char*>;
            using pair_of_strings = std::pair<const std::string&, const std::string&>;

            class member_type {

                osmium::item_type      m_type;
                osmium::object_id_type m_ref;
                const char*            m_role;

            public:

                constexpr member_type(osmium::item_type type, osmium::object_id_type ref, const char* role = "") noexcept :
                    m_type(type),
                    m_ref(ref),
                    m_role(role) {
                }

                constexpr osmium::item_type type() const noexcept {
                    return m_type;
                }

                constexpr osmium::object_id_type ref() const noexcept {
                    return m_ref;
                }

                constexpr const char* role() const noexcept {
                    return m_role;
                }

            }; // class member_type

            namespace detail {

                OSMIUM_ATTRIBUTE_ITER(tags_handler, tags_from_iterator_pair);

                OSMIUM_ATTRIBUTE_ITER(nodes_handler, nodes_from_iterator_pair);

                OSMIUM_ATTRIBUTE_ITER(members_handler, members_from_iterator_pair);

            } // namespace detail

            OSMIUM_ATTRIBUTE(tags_handler, _tag, pair_of_cstrings)
                explicit _tag(const pair_of_cstrings& value) :
                    type_wrapper(value) {}
                explicit _tag(const pair_of_strings& value) :
                    type_wrapper(std::make_pair(value.first.c_str(), value.second.c_str())) {}
                explicit _tag(const char* key, const char* val) :
                    type_wrapper(std::make_pair(key, val)) {}
                explicit _tag(const std::string& key, const std::string& val) :
                    type_wrapper(std::make_pair(key.c_str(), val.c_str())) {}
            };

            template <typename TTagIterator>
            inline constexpr detail::tags_from_iterator_pair<TTagIterator> _tags(TTagIterator first, TTagIterator last) {
                return detail::tags_from_iterator_pair<TTagIterator>(first, last);
            }

            template <typename TContainer>
            inline detail::tags_from_iterator_pair<typename TContainer::const_iterator> _tags(const TContainer& container) {
                return detail::tags_from_iterator_pair<typename TContainer::const_iterator>(std::begin(container), std::end(container));
            }

            using tag_ilist = std::initializer_list<std::pair<const char*, const char*>>;
            inline detail::tags_from_iterator_pair<tag_ilist::const_iterator> _tags(const tag_ilist& container) {
                return detail::tags_from_iterator_pair<tag_ilist::const_iterator>(std::begin(container), std::end(container));
            }



            OSMIUM_ATTRIBUTE(nodes_handler, _node, osmium::NodeRef)
                constexpr explicit _node(osmium::object_id_type value) :
                    type_wrapper(NodeRef{value}) {}
                constexpr explicit _node(const NodeRef& value) :
                    type_wrapper(value) {}
            };

            template <typename TIdIterator>
            inline constexpr detail::nodes_from_iterator_pair<TIdIterator> _nodes(TIdIterator first, TIdIterator last) {
                return detail::nodes_from_iterator_pair<TIdIterator>(first, last);
            }

            template <typename TContainer>
            inline detail::nodes_from_iterator_pair<typename TContainer::const_iterator> _nodes(const TContainer& container) {
                return detail::nodes_from_iterator_pair<typename TContainer::const_iterator>(std::begin(container), std::end(container));
            }

            using object_id_ilist = std::initializer_list<osmium::object_id_type>;
            inline detail::nodes_from_iterator_pair<object_id_ilist::const_iterator> _nodes(const object_id_ilist& container) {
                return detail::nodes_from_iterator_pair<object_id_ilist::const_iterator>(std::begin(container), std::end(container));
            }

            using node_ref_ilist = std::initializer_list<osmium::NodeRef>;
            inline detail::nodes_from_iterator_pair<node_ref_ilist::const_iterator> _nodes(const node_ref_ilist& container) {
                return detail::nodes_from_iterator_pair<node_ref_ilist::const_iterator>(std::begin(container), std::end(container));
            }


            OSMIUM_ATTRIBUTE(members_handler, _member, member_type)
                explicit _member(const member_type& value) :
                    type_wrapper(value) {}
                explicit _member(osmium::item_type type, osmium::object_id_type id) :
                    type_wrapper({type, id}) {}
                explicit _member(osmium::item_type type, osmium::object_id_type id, const char* role) :
                    type_wrapper({type, id, role}) {}
                explicit _member(osmium::item_type type, osmium::object_id_type id, const std::string& role) :
                    type_wrapper({type, id, role.c_str()}) {}
                explicit _member(const osmium::RelationMember& member) :
                    type_wrapper({member.type(), member.ref(), member.role()}) {}
            };

            template <typename TMemberIterator>
            inline constexpr detail::members_from_iterator_pair<TMemberIterator> _members(TMemberIterator first, TMemberIterator last) {
                return detail::members_from_iterator_pair<TMemberIterator>(first, last);
            }

            template <typename TContainer>
            inline detail::members_from_iterator_pair<typename TContainer::const_iterator> _members(const TContainer& container) {
                return detail::members_from_iterator_pair<typename TContainer::const_iterator>(std::begin(container), std::end(container));
            }

            using member_ilist = std::initializer_list<member_type>;
            inline detail::members_from_iterator_pair<member_ilist::const_iterator> _members(const member_ilist& container) {
                return detail::members_from_iterator_pair<member_ilist::const_iterator>(std::begin(container), std::end(container));
            }

        } // namespace attr

#undef OSMIUM_ATTRIBUTE_ITER
#undef OSMIUM_ATTRIBUTE_WITH_CONSTRUCTOR
#undef OSMIUM_ATTRIBUTE

        namespace detail {

            struct basic_handler {

                template <typename TDummy>
                void operator()(osmium::OSMObject&, const TDummy&) const noexcept {
                }

                void operator()(osmium::OSMObject& object, attr::_id id) const noexcept {
                    object.set_id(id.value);
                }

                void operator()(osmium::OSMObject& object, attr::_version version) const noexcept {
                    object.set_version(version.value);
                }

                void operator()(osmium::OSMObject& object, attr::_visible visible) const noexcept {
                    object.set_visible(visible.value);
                }

                void operator()(osmium::OSMObject& object, attr::_deleted deleted) const noexcept {
                    object.set_deleted(deleted.value);
                }

                void operator()(osmium::OSMObject& object, attr::_timestamp timestamp) const noexcept {
                    object.set_timestamp(timestamp.value);
                }

                void operator()(osmium::OSMObject& object, attr::_changeset changeset) const noexcept {
                    object.set_changeset(changeset.value);
                }

                void operator()(osmium::OSMObject& object, attr::_uid uid) const noexcept {
                    object.set_uid(uid.value);
                }

            }; // basic_handler

            struct node_handler : public basic_handler {

                using basic_handler::operator();

                void operator()(osmium::Node& node, attr::_location location) const noexcept {
                    node.set_location(location.value);
                }

            }; // node_handler

            template <typename THandler, typename TBuilder, typename... TArgs>
            inline void add_basic(TBuilder& builder, const TArgs&... args) {
                THandler handler;
                (void)std::initializer_list<int>{
                    (handler(builder.object(), args), 0)...
                };
            }

            // ==============================================================

            template <typename... TArgs>
            inline constexpr const char* get_user(const attr::_user& user, const TArgs&...) noexcept {
                return user.value;
            }

            inline constexpr const char* get_user() noexcept {
                return "";
            }

            template <typename TFirst, typename... TRest>
            inline constexpr typename std::enable_if<!std::is_same<attr::_user, TFirst>::value, const char*>::type
            get_user(const TFirst&, const TRest&... args) noexcept {
                return get_user(args...);
            }

            template <typename TBuilder, typename... TArgs>
            inline void add_user(TBuilder& builder, const TArgs&... args) {
                builder.add_user(get_user(args...));
            }

            // ==============================================================

            struct tags_handler {

                template <typename TDummy>
                void operator()(TagListBuilder&, const TDummy&) const noexcept {
                }

                void operator()(TagListBuilder& builder, const attr::_tag& tag) const {
                    builder.add_tag(tag.value);
                }

                template <typename TIterator>
                void operator()(TagListBuilder& builder, const attr::detail::tags_from_iterator_pair<TIterator>& tags) const {
                    for (const auto& tag : tags) {
                        builder.add_tag(tag);
                    }
                }

            }; // struct tags_handler

            struct nodes_handler {

                template <typename TDummy>
                void operator()(WayNodeListBuilder&, const TDummy&) const noexcept {
                }

                void operator()(WayNodeListBuilder& builder, const attr::_node& node_ref) const {
                    builder.add_node_ref(node_ref.value);
                }

                template <typename TIterator>
                void operator()(WayNodeListBuilder& builder, const attr::detail::nodes_from_iterator_pair<TIterator>& nodes) const {
                    for (const auto& ref : nodes) {
                        builder.add_node_ref(ref);
                    }
                }

            }; // struct nodes_handler

            struct members_handler {

                template <typename TDummy>
                void operator()(RelationMemberListBuilder&, const TDummy&) const noexcept {
                }

                void operator()(RelationMemberListBuilder& builder, const attr::_member& member) const {
                    builder.add_member(member.value.type(), member.value.ref(), member.value.role());
                }

                template <typename TIterator>
                void operator()(RelationMemberListBuilder& builder, const attr::detail::members_from_iterator_pair<TIterator>& members) const {
                    for (const auto& member : members) {
                        builder.add_member(member.type(), member.ref(), member.role());
                    }
                }

            }; // struct members_handler

            // ==============================================================

            template <typename TBuilder, typename THandler, typename... TArgs>
            inline typename std::enable_if<!is_handled_by<THandler, TArgs...>::any>::type
            add_list(osmium::builder::Builder&, const TArgs&...) {
            }

            template <typename TBuilder, typename THandler, typename... TArgs>
            inline typename std::enable_if<is_handled_by<THandler, TArgs...>::any>::type
            add_list(osmium::builder::Builder& parent, const TArgs&... args) {
                TBuilder builder(parent.buffer(), &parent);
                THandler handler;
                (void)std::initializer_list<int>{
                    (handler(builder, args), 0)...
                };
            }

            struct any_node_handlers : public node_handler, public tags_handler {};
            struct any_way_handlers : public basic_handler, public tags_handler, public nodes_handler {};
            struct any_relation_handlers : public basic_handler, public tags_handler, public members_handler {};

        } // namespace detail

        template <typename... TArgs>
        inline size_t add_node(osmium::memory::Buffer& buffer, const TArgs&... args) {
            static_assert(sizeof...(args) > 0, "add_node() must have buffer and at least one additional argument");
            static_assert(detail::is_handled_by<detail::any_node_handlers, TArgs...>::all, "Type not allowed in add_node()");

            NodeBuilder builder(buffer);

            detail::add_basic<detail::node_handler>(builder, args...);
            detail::add_user(builder, args...);
            detail::add_list<TagListBuilder, detail::tags_handler>(builder, args...);

            return buffer.commit();
        }

        template <typename... TArgs>
        inline size_t add_way(osmium::memory::Buffer& buffer, const TArgs&... args) {
            static_assert(sizeof...(args) > 0, "add_way() must have buffer and at least one additional argument");
            static_assert(detail::is_handled_by<detail::any_way_handlers, TArgs...>::all, "Type not allowed in add_way()");

            WayBuilder builder(buffer);

            detail::add_basic<detail::basic_handler>(builder, args...);
            detail::add_user(builder, args...);
            detail::add_list<TagListBuilder, detail::tags_handler>(builder, args...);
            detail::add_list<WayNodeListBuilder, detail::nodes_handler>(builder, args...);

            return buffer.commit();
        }

        template <typename... TArgs>
        inline size_t add_relation(osmium::memory::Buffer& buffer, const TArgs&... args) {
            static_assert(sizeof...(args) > 0, "add_relation() must have buffer and at least one additional argument");
            static_assert(detail::is_handled_by<detail::any_relation_handlers, TArgs...>::all, "Type not allowed in add_relation()");

            RelationBuilder builder(buffer);

            detail::add_basic<detail::basic_handler>(builder, args...);
            detail::add_user(builder, args...);
            detail::add_list<TagListBuilder, detail::tags_handler>(builder, args...);
            detail::add_list<RelationMemberListBuilder, detail::members_handler>(builder, args...);

            return buffer.commit();
        }

    } // namespace builder

} // namespace osmium

#endif // OSMIUM_BUILDER_ATTR_HPP
